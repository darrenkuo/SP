<P>We're going to write, using the leap of faith method, a recursive procedure
to reverse the letters of a word:
 
<P><PRE>&gt; (reverse 'beatles)
SELTAEB
</PRE> 
 
<P>Is there a <CODE>reverse</CODE> of a smaller argument lurking within
that return value?  Yes, many of them.  For example, <CODE>LTA</CODE> is the
<CODE>reverse</CODE> of the word <CODE>ATL</CODE>.  But it will be most helpful if we
find a smaller subproblem that's only <EM>slightly</EM> smaller.  (This idea
corresponds to writing <CODE>letter-pairs7</CODE> using <CODE>letter-pairs6</CODE> in the
combining method.)  The closest smaller subproblem to our original problem
is to find the <CODE>reverse</CODE> of a word one letter shorter than <CODE>beatles</CODE>.
 
<P><PRE>&gt; (reverse 'beatle)
ELTAEB
</PRE> 
 
<P>This result is pretty close to the answer we want for <CODE>reverse</CODE>
of <CODE>beatles</CODE>.  What's the relationship between <CODE>ELTAEB</CODE>,
the answer to the smaller problem, and <CODE>SELTAEB</CODE>, the answer to the
entire problem?  There's one extra letter, <CODE>S</CODE>, at the beginning.
Where did the extra letter come from?  Obviously, it's the last letter of
<CODE>beatles</CODE>.

<P><small><small>There's also a relationship between <code>(reverse
'eatles)</code> and <code>(reverse 'beatles)</code>, with the extra letter
<code>b</code> at the end.  We could take either of these subproblems as a
starting point and end up with a working procedure.</small></small>
 
<P>This may seem like a sequence of trivial observations leading nowhere.  But
as a result of this investigation, we can translate what we've learned
directly into Scheme.  In English:  &quot;the <CODE>reverse</CODE> of a word consists
of its last letter followed by the <CODE>reverse</CODE> of its <CODE>butlast</CODE>.&quot; In
Scheme:
 
<P><PRE>(define (reverse wd)                    ;; unfinished
  (word (last wd)
    (reverse (bl wd))))
</PRE> 

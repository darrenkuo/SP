<b>CS 61A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Week 13</b>
<div class="p"><!----></div>
Topic: Analyzing evaluator, MapReduce
<div class="p"><!----></div>
<b>Reading:</b>
Therac paper in course reader.
<div class="p"><!----></div>
analyzing evaluator: <tt>&#126;cs61a/lib/analyze.scm</tt>

<div class="p"><!----></div>
<b>Homework:</b>
<div class="p"><!----></div>
A&amp;S exercises 4.22, 4.23, 4.24

<div class="p"><!----></div>
MapReduce exercises:

<div class="p"><!----></div>
1(a). Google uses MapReduce for a variety of search-engine-related tasks
involving processing large data sets. An example of such a task is building an
inverted word index. For each word in a given set of documents, we want to
generate a key-value pair, where the key is the word and the value is all
documents in which the word appears.  Write a procedure that takes a directory
name as argument and returns the inverted index stream.

<div class="p"><!----></div>
1(b). The list above will include words like "a," "so," "the," etc.
Suppose now that we only want "important words." We can use word length as a
measure of importance (a real search engine would use a more complex
heuristic). Write a procedure that returns an index where all the words are N
or more letters long, taking the filename and N as arguments.

<div class="p"><!----></div>
2.  Google also manages the GMail e-mail service, and they would like to
filter out as many spammers as possible. In this problem you will implement a
simple spam filtering idea with <tt>mapreduce</tt> so that it can be efficiently
applied to the multitudes of e-mail messages in GMail.

<div class="p"><!----></div>
We want to produce a "blacklist" of e-mail addresses that are spamming GMail
users. Spam messages are sent to many addresses at once, and so a spam message
can be identified by having one of the most commonly-used subject lines. If an
address sends many messages with the most common subject lines, it is likely a
spammer address. We would like to find the top ten addresses that have sent
the most messages with frequently-recurring subject lines.

<div class="p"><!----></div>
The input data is a collection of e-mail records in the file <tt>
/sample-emails</tt>. (These are simulated messages, not actual GMail data!)
Each e-mail record is a list with the format

<div class="p"><!----></div>
<tt>  <pre>(from-address to-address subject body)

</pre></tt>

<div class="p"><!----></div>
where each element is a double-quoted string. The mapper function will be
applied to each e-mail record. An small example set of e-mail records is
below.

<div class="p"><!----></div>
<tt>  <pre>("cs61a-tb" "cs61a-tc" "mapreduce" "mapreduce is great! lucky students!")
("bot1337" "cs61a-ta" "free ipod now!" "buy herbal ipod enhancer!")
("bot1338" "cs61c-tf" "free ipod now!" "buy herbal ipod enhancer!")
...

</pre></tt>

<div class="p"><!----></div>
<b>Problem continues on next page...</b>

<div class="p"><!----></div>
<b>Week 13 continued:</b>

<div class="p"><!----></div>
2(a). Our first step is to produce a table with subject lines as keys and
counts of occurrences as values. Identify the intermediate key-value pairs and
write the mapper and reducer functions.

<div class="p"><!----></div>
2(b). From our tabulation of subject line occurrences in 2(a), we want to find
the most common subject lines in the table. We can perform a sort by using the
fact that MapReduce sorts by intermediate keys into the reducer groups.
Identify the intermediate key-value pairs and write the mapper and reducer
functions.

<div class="p"><!----></div>
2(c). Finally, assuming you've moved the ten most common subject lines into a
list, we want to make a table with from-addresses as keys and counts of
e-mails sent with common subject lines as values. You don't need to sort the
table, since the procedures would be identical to those in 2(b). Identify the
intermediate key-value pairs and write the mapper and reducer functions.

<div class="p"><!----></div>
3.  Sometimes either the map or reduce operation is trivial, such as an
identity function. Is MapReduce still the best way to handle those cases,
or would it be better to provide separate <tt>map</tt> and <tt>groupreduce</tt>
functions as we did for the non-parallel toy version?  Why?

<div class="p"><!----></div>
4.  Could you use MapReduce to perform a parallelized Sieve of Eratosthenes?
If so, describe the process briefly. If not, why not?  (Don't try to solve
this problem by quizmanship; there's a case to be made for both answers!)

<div class="p"><!----></div>
<b>Note:</b> Part I of project 4 is also due next week.

<div class="p"><!----></div>
<br /><hr />
Unix feature of the week: <tt>sort</tt>, <tt>cut</tt>, <tt>paste</tt>, <tt>join</tt>
<div class="p"><!----></div>
Emacs feature of the week: <tt>C-x</tt> <tt>C-o</tt>, <tt>M-'134</tt> (delete blank space)
<div class="p"><!----></div>

<div class="p"><!----></div>

<div class="p"><!----></div>
